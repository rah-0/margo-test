package Beta

// ---------------------------------------------------------------
// The code in this file is autogenerated, do not modify manually!
// ---------------------------------------------------------------

import (
	"context"
	"database/sql"
	"errors"
	"strings"
	"sync"
)

const (
	FQTN             = "`template`.`beta`"
	FieldFirstInsert = "first_insert"
	FieldLastUpdate  = "last_update"
	FieldUuid        = "uuid"
	FieldName        = "name"
)

var (
	Fields    = []string{FieldFirstInsert, FieldLastUpdate, FieldUuid, FieldName}
	db        *sql.DB
	stmtMu    sync.RWMutex
	stmtCache = make(map[string]*sql.Stmt)
)

type Entity struct {
	FirstInsert string `json:",omitempty,omitzero"`
	LastUpdate  string `json:",omitempty,omitzero"`
	Uuid        string `json:",omitempty,omitzero"`
	Name        string `json:",omitempty,omitzero"`
}

type QueryParams struct {
	Select []string
	Where  []string
	Insert []string
	Update []string
	Params []any
}

func NewQueryParams() *QueryParams {
	return &QueryParams{}
}

func (qp *QueryParams) WithSelect(fields ...string) *QueryParams {
	qp.Select = fields
	return qp
}

func (qp *QueryParams) WithWhere(fields ...string) *QueryParams {
	qp.Where = fields
	return qp
}

func (qp *QueryParams) WithInsert(fields ...string) *QueryParams {
	qp.Insert = fields
	return qp
}

func (qp *QueryParams) WithUpdate(fields ...string) *QueryParams {
	qp.Update = fields
	return qp
}

func (qp *QueryParams) WithParams(params ...any) *QueryParams {
	qp.Params = params
	return qp
}

type QueryResult struct {
	Entities []*Entity
	Error    error
	Result   sql.Result
	Exists   bool
}

func SetDB(x *sql.DB) error {
	db = x
	return nil
}

func (x *Entity) GetFieldValue(field string) any {
	switch field {
	case FieldFirstInsert:
		return x.FirstInsert
	case FieldLastUpdate:
		return x.LastUpdate
	case FieldUuid:
		return x.Uuid
	case FieldName:
		return x.Name
	}
	return nil
}

func (x *Entity) GetFieldsValues(fieldList []string) []any {
	values := make([]any, 0, len(fieldList))
	for _, field := range fieldList {
		values = append(values, x.GetFieldValue(field))
	}
	return values
}

func GetValuePlaceholder(field string) string {
	switch field {
	case FieldFirstInsert:
		return "?"
	case FieldLastUpdate:
		return "?"
	case FieldUuid:
		return "?"
	case FieldName:
		return "?"
	}
	return ""
}

func GetValuesPlaceholders(fieldList []string) []string {
	placeholders := make([]string, 0, len(fieldList))
	for _, field := range fieldList {
		placeholders = append(placeholders, GetValuePlaceholder(field))
	}
	return placeholders
}

func GetQualifiedField(field string) string {
	switch field {
	case FieldFirstInsert:
		return FQTN + ".`" + FieldFirstInsert + "`"
	case FieldLastUpdate:
		return FQTN + ".`" + FieldLastUpdate + "`"
	case FieldUuid:
		return FQTN + ".`" + FieldUuid + "`"
	case FieldName:
		return FQTN + ".`" + FieldName + "`"
	}
	return ""
}

func GetQualifiedFields(fieldList []string) []string {
	fields := make([]string, 0, len(fieldList))
	for _, field := range fieldList {
		fields = append(fields, GetQualifiedField(field))
	}
	return fields
}

func GetQualifiedPlaceholder(field string) string {
	switch field {
	case FieldFirstInsert:
		return FQTN + ".`" + FieldFirstInsert + "` = ?"
	case FieldLastUpdate:
		return FQTN + ".`" + FieldLastUpdate + "` = ?"
	case FieldUuid:
		return FQTN + ".`" + FieldUuid + "` = ?"
	case FieldName:
		return FQTN + ".`" + FieldName + "` = ?"
	}
	return ""
}

func GetQualifiedPlaceholders(fieldList []string) []string {
	placeholders := make([]string, 0, len(fieldList))
	for _, field := range fieldList {
		placeholders = append(placeholders, GetQualifiedPlaceholder(field))
	}
	return placeholders
}

func getPreparedStmt(query string) (*sql.Stmt, error) {
	stmtMu.RLock()
	if stmt, ok := stmtCache[query]; ok {
		stmtMu.RUnlock()
		return stmt, nil
	}
	stmtMu.RUnlock()

	stmtMu.Lock()
	defer stmtMu.Unlock()
	if stmt, ok := stmtCache[query]; ok {
		return stmt, nil
	}
	stmt, err := db.Prepare(query)
	if err != nil {
		return nil, err
	}
	stmtCache[query] = stmt
	return stmt, nil
}

func scanRow(fields []string, rows *sql.Rows) (*Entity, error) {
	x := &Entity{}
	var (
		ptrFirstInsert *string
		ptrLastUpdate  *string
		ptrUuid        *string
		ptrName        *string
		scanTargets    []any
	)

	for _, field := range fields {
		switch field {
		case FieldFirstInsert:
			scanTargets = append(scanTargets, &ptrFirstInsert)
		case FieldLastUpdate:
			scanTargets = append(scanTargets, &ptrLastUpdate)
		case FieldUuid:
			scanTargets = append(scanTargets, &ptrUuid)
		case FieldName:
			scanTargets = append(scanTargets, &ptrName)
		}
	}

	err := rows.Scan(scanTargets...)
	if err != nil {
		return nil, err
	}

	if ptrFirstInsert != nil {
		x.FirstInsert = *ptrFirstInsert
	} else {
		x.FirstInsert = ""
	}
	if ptrLastUpdate != nil {
		x.LastUpdate = *ptrLastUpdate
	} else {
		x.LastUpdate = ""
	}
	if ptrUuid != nil {
		x.Uuid = *ptrUuid
	} else {
		x.Uuid = ""
	}
	if ptrName != nil {
		x.Name = *ptrName
	} else {
		x.Name = ""
	}
	return x, nil
}

func readRows(fields []string, rows *sql.Rows) ([]*Entity, error) {
	defer rows.Close()
	var results []*Entity
	for rows.Next() {
		x, err := scanRow(fields, rows)
		if err != nil {
			return results, err
		}
		results = append(results, x)
	}
	if err := rows.Err(); err != nil {
		return results, err
	}
	return results, nil
}

func bindStmtCtxTx(base *sql.Stmt, ctx context.Context, tx *sql.Tx) (*sql.Stmt, bool) {
	if tx == nil {
		return base, false
	}
	if ctx != nil {
		return tx.StmtContext(ctx, base), true
	}
	return tx.Stmt(base), true
}

func execCore(ctx context.Context, tx *sql.Tx, query string, args ...any) (res sql.Result, err error) {
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	s, needClose := bindStmtCtxTx(stmt, ctx, tx)
	if needClose {
		defer func() {
			if cerr := s.Close(); err == nil && cerr != nil {
				err = cerr
			}
		}()
	}
	if ctx != nil {
		return s.ExecContext(ctx, args...)
	}
	return s.Exec(args...)
}

func queryCore(ctx context.Context, tx *sql.Tx, fields []string, query string, args ...any) (out []*Entity, err error) {
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	s, needClose := bindStmtCtxTx(stmt, ctx, tx)
	if needClose {
		defer func() {
			if cerr := s.Close(); err == nil && cerr != nil {
				err = cerr
			}
		}()
	}
	var rows *sql.Rows
	if ctx != nil {
		rows, err = s.QueryContext(ctx, args...)
	} else {
		rows, err = s.Query(args...)
	}
	if err != nil {
		return nil, err
	}
	return readRows(fields, rows)
}

func scalarCore(ctx context.Context, tx *sql.Tx, query string, args ...any) (int, error) {
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return 0, err
	}
	s, needClose := bindStmtCtxTx(stmt, ctx, tx)
	if needClose {
		defer s.Close()
	}
	var v int
	if ctx != nil {
		err = s.QueryRowContext(ctx, args...).Scan(&v)
	} else {
		err = s.QueryRow(args...).Scan(&v)
	}
	return v, err
}

func DBTruncate() *QueryResult {
	res, err := execCore(nil, nil, "TRUNCATE TABLE "+FQTN)
	return &QueryResult{Result: res, Error: err}
}
func DBTruncateCtx(ctx context.Context) *QueryResult {
	res, err := execCore(ctx, nil, "TRUNCATE TABLE "+FQTN)
	return &QueryResult{Result: res, Error: err}
}
func DBTruncateTx(tx *sql.Tx) *QueryResult {
	res, err := execCore(nil, tx, "TRUNCATE TABLE "+FQTN)
	return &QueryResult{Result: res, Error: err}
}
func DBTruncateCtxTx(ctx context.Context, tx *sql.Tx) *QueryResult {
	res, err := execCore(ctx, tx, "TRUNCATE TABLE "+FQTN)
	return &QueryResult{Result: res, Error: err}
}

func (x *Entity) DBInsert(params *QueryParams) *QueryResult {
	fieldsToInsert := Fields
	if params != nil && len(params.Insert) > 0 {
		fieldsToInsert = params.Insert
	}
	q := "INSERT INTO " + FQTN + " (" + strings.Join(GetQualifiedFields(fieldsToInsert), ", ") + ") VALUES (" + strings.Join(GetValuesPlaceholders(fieldsToInsert), ", ") + ")"
	res, err := execCore(nil, nil, q, x.GetFieldsValues(fieldsToInsert)...)
	return &QueryResult{Result: res, Error: err}
}

func (x *Entity) DBInsertCtx(ctx context.Context, params *QueryParams) *QueryResult {
	fieldsToInsert := Fields
	if params != nil && len(params.Insert) > 0 {
		fieldsToInsert = params.Insert
	}
	q := "INSERT INTO " + FQTN + " (" + strings.Join(GetQualifiedFields(fieldsToInsert), ", ") + ") VALUES (" + strings.Join(GetValuesPlaceholders(fieldsToInsert), ", ") + ")"
	res, err := execCore(ctx, nil, q, x.GetFieldsValues(fieldsToInsert)...)
	return &QueryResult{Result: res, Error: err}
}

func (x *Entity) DBInsertTx(tx *sql.Tx, params *QueryParams) *QueryResult {
	fieldsToInsert := Fields
	if params != nil && len(params.Insert) > 0 {
		fieldsToInsert = params.Insert
	}
	q := "INSERT INTO " + FQTN + " (" + strings.Join(GetQualifiedFields(fieldsToInsert), ", ") + ") VALUES (" + strings.Join(GetValuesPlaceholders(fieldsToInsert), ", ") + ")"
	res, err := execCore(nil, tx, q, x.GetFieldsValues(fieldsToInsert)...)
	return &QueryResult{Result: res, Error: err}
}

func (x *Entity) DBInsertCtxTx(ctx context.Context, tx *sql.Tx, params *QueryParams) *QueryResult {
	fieldsToInsert := Fields
	if params != nil && len(params.Insert) > 0 {
		fieldsToInsert = params.Insert
	}
	q := "INSERT INTO " + FQTN + " (" + strings.Join(GetQualifiedFields(fieldsToInsert), ", ") + ") VALUES (" + strings.Join(GetValuesPlaceholders(fieldsToInsert), ", ") + ")"
	res, err := execCore(ctx, tx, q, x.GetFieldsValues(fieldsToInsert)...)
	return &QueryResult{Result: res, Error: err}
}

func (x *Entity) DBDelete(params *QueryParams) *QueryResult {
	whereFields := Fields
	if params != nil && len(params.Where) > 0 {
		whereFields = params.Where
	}
	q := "DELETE FROM " + FQTN + " WHERE " + strings.Join(GetQualifiedFields(whereFields), " = ? AND ") + " = ?"
	res, err := execCore(nil, nil, q, x.GetFieldsValues(whereFields)...)
	return &QueryResult{Result: res, Error: err}
}

func (x *Entity) DBDeleteCtx(ctx context.Context, params *QueryParams) *QueryResult {
	whereFields := Fields
	if params != nil && len(params.Where) > 0 {
		whereFields = params.Where
	}
	q := "DELETE FROM " + FQTN + " WHERE " + strings.Join(GetQualifiedFields(whereFields), " = ? AND ") + " = ?"
	res, err := execCore(ctx, nil, q, x.GetFieldsValues(whereFields)...)
	return &QueryResult{Result: res, Error: err}
}

func (x *Entity) DBDeleteTx(tx *sql.Tx, params *QueryParams) *QueryResult {
	whereFields := Fields
	if params != nil && len(params.Where) > 0 {
		whereFields = params.Where
	}
	q := "DELETE FROM " + FQTN + " WHERE " + strings.Join(GetQualifiedFields(whereFields), " = ? AND ") + " = ?"
	res, err := execCore(nil, tx, q, x.GetFieldsValues(whereFields)...)
	return &QueryResult{Result: res, Error: err}
}

func (x *Entity) DBDeleteCtxTx(ctx context.Context, tx *sql.Tx, params *QueryParams) *QueryResult {
	whereFields := Fields
	if params != nil && len(params.Where) > 0 {
		whereFields = params.Where
	}
	q := "DELETE FROM " + FQTN + " WHERE " + strings.Join(GetQualifiedFields(whereFields), " = ? AND ") + " = ?"
	res, err := execCore(ctx, tx, q, x.GetFieldsValues(whereFields)...)
	return &QueryResult{Result: res, Error: err}
}

func (x *Entity) DBUpdate(params *QueryParams) *QueryResult {
	if params == nil || len(params.Update) == 0 || len(params.Where) == 0 {
		return &QueryResult{Error: errors.New("DBUpdate requires both params.Update and params.Where to be specified")}
	}
	q := "UPDATE " + FQTN + " SET " + strings.Join(GetQualifiedPlaceholders(params.Update), ", ") + " WHERE " + strings.Join(GetQualifiedFields(params.Where), " = ? AND ") + " = ?"
	vals := append(x.GetFieldsValues(params.Update), x.GetFieldsValues(params.Where)...)
	res, err := execCore(nil, nil, q, vals...)
	return &QueryResult{Result: res, Error: err}
}

func (x *Entity) DBUpdateCtx(ctx context.Context, params *QueryParams) *QueryResult {
	if params == nil || len(params.Update) == 0 || len(params.Where) == 0 {
		return &QueryResult{Error: errors.New("DBUpdate requires both params.Update and params.Where to be specified")}
	}
	q := "UPDATE " + FQTN + " SET " + strings.Join(GetQualifiedPlaceholders(params.Update), ", ") + " WHERE " + strings.Join(GetQualifiedFields(params.Where), " = ? AND ") + " = ?"
	vals := append(x.GetFieldsValues(params.Update), x.GetFieldsValues(params.Where)...)
	res, err := execCore(ctx, nil, q, vals...)
	return &QueryResult{Result: res, Error: err}
}

func (x *Entity) DBUpdateTx(tx *sql.Tx, params *QueryParams) *QueryResult {
	if params == nil || len(params.Update) == 0 || len(params.Where) == 0 {
		return &QueryResult{Error: errors.New("DBUpdate requires both params.Update and params.Where to be specified")}
	}
	q := "UPDATE " + FQTN + " SET " + strings.Join(GetQualifiedPlaceholders(params.Update), ", ") + " WHERE " + strings.Join(GetQualifiedFields(params.Where), " = ? AND ") + " = ?"
	vals := append(x.GetFieldsValues(params.Update), x.GetFieldsValues(params.Where)...)
	res, err := execCore(nil, tx, q, vals...)
	return &QueryResult{Result: res, Error: err}
}

func (x *Entity) DBUpdateCtxTx(ctx context.Context, tx *sql.Tx, params *QueryParams) *QueryResult {
	if params == nil || len(params.Update) == 0 || len(params.Where) == 0 {
		return &QueryResult{Error: errors.New("DBUpdate requires both params.Update and params.Where to be specified")}
	}
	q := "UPDATE " + FQTN + " SET " + strings.Join(GetQualifiedPlaceholders(params.Update), ", ") + " WHERE " + strings.Join(GetQualifiedFields(params.Where), " = ? AND ") + " = ?"
	vals := append(x.GetFieldsValues(params.Update), x.GetFieldsValues(params.Where)...)
	res, err := execCore(ctx, tx, q, vals...)
	return &QueryResult{Result: res, Error: err}
}

func (x *Entity) DBSelect(params *QueryParams) *QueryResult {
	fieldsToSelect := Fields
	if params != nil && len(params.Select) > 0 {
		fieldsToSelect = params.Select
	}
	q := "SELECT " + strings.Join(GetQualifiedFields(fieldsToSelect), ", ") + " FROM " + FQTN
	var args []any
	if params != nil && len(params.Where) > 0 {
		q += " WHERE " + strings.Join(GetQualifiedFields(params.Where), " = ? AND ") + " = ?"
		args = x.GetFieldsValues(params.Where)
	}
	entities, err := queryCore(nil, nil, fieldsToSelect, q, args...)
	return &QueryResult{Entities: entities, Error: err}
}

func (x *Entity) DBSelectCtx(ctx context.Context, params *QueryParams) *QueryResult {
	fieldsToSelect := Fields
	if params != nil && len(params.Select) > 0 {
		fieldsToSelect = params.Select
	}
	q := "SELECT " + strings.Join(GetQualifiedFields(fieldsToSelect), ", ") + " FROM " + FQTN
	var args []any
	if params != nil && len(params.Where) > 0 {
		q += " WHERE " + strings.Join(GetQualifiedFields(params.Where), " = ? AND ") + " = ?"
		args = x.GetFieldsValues(params.Where)
	}
	entities, err := queryCore(ctx, nil, fieldsToSelect, q, args...)
	return &QueryResult{Entities: entities, Error: err}
}

func (x *Entity) DBSelectTx(tx *sql.Tx, params *QueryParams) *QueryResult {
	fieldsToSelect := Fields
	if params != nil && len(params.Select) > 0 {
		fieldsToSelect = params.Select
	}
	q := "SELECT " + strings.Join(GetQualifiedFields(fieldsToSelect), ", ") + " FROM " + FQTN
	var args []any
	if params != nil && len(params.Where) > 0 {
		q += " WHERE " + strings.Join(GetQualifiedFields(params.Where), " = ? AND ") + " = ?"
		args = x.GetFieldsValues(params.Where)
	}
	entities, err := queryCore(nil, tx, fieldsToSelect, q, args...)
	return &QueryResult{Entities: entities, Error: err}
}

func (x *Entity) DBSelectCtxTx(ctx context.Context, tx *sql.Tx, params *QueryParams) *QueryResult {
	fieldsToSelect := Fields
	if params != nil && len(params.Select) > 0 {
		fieldsToSelect = params.Select
	}
	q := "SELECT " + strings.Join(GetQualifiedFields(fieldsToSelect), ", ") + " FROM " + FQTN
	var args []any
	if params != nil && len(params.Where) > 0 {
		q += " WHERE " + strings.Join(GetQualifiedFields(params.Where), " = ? AND ") + " = ?"
		args = x.GetFieldsValues(params.Where)
	}
	entities, err := queryCore(ctx, tx, fieldsToSelect, q, args...)
	return &QueryResult{Entities: entities, Error: err}
}

func DBSelectAll() *QueryResult {
	q := "SELECT " + strings.Join(GetQualifiedFields(Fields), ", ") + " FROM " + FQTN
	entities, err := queryCore(nil, nil, Fields, q)
	return &QueryResult{Entities: entities, Error: err}
}

func DBSelectAllCtx(ctx context.Context) *QueryResult {
	q := "SELECT " + strings.Join(GetQualifiedFields(Fields), ", ") + " FROM " + FQTN
	entities, err := queryCore(ctx, nil, Fields, q)
	return &QueryResult{Entities: entities, Error: err}
}

func DBSelectAllTx(tx *sql.Tx) *QueryResult {
	q := "SELECT " + strings.Join(GetQualifiedFields(Fields), ", ") + " FROM " + FQTN
	entities, err := queryCore(nil, tx, Fields, q)
	return &QueryResult{Entities: entities, Error: err}
}

func DBSelectAllCtxTx(ctx context.Context, tx *sql.Tx) *QueryResult {
	q := "SELECT " + strings.Join(GetQualifiedFields(Fields), ", ") + " FROM " + FQTN
	entities, err := queryCore(ctx, tx, Fields, q)
	return &QueryResult{Entities: entities, Error: err}
}

func (x *Entity) DBExists(params *QueryParams) *QueryResult {
	if params == nil {
		return &QueryResult{Error: errors.New("DBExists requires params to be specified"), Exists: false}
	}
	fieldsToSelect := params.Select
	if len(fieldsToSelect) == 0 {
		fieldsToSelect = Fields
	}
	whereFields := params.Where
	if len(whereFields) == 0 {
		whereFields = Fields
	}
	q := "SELECT " + strings.Join(GetQualifiedFields(fieldsToSelect), ", ") + " FROM " + FQTN + " WHERE " + strings.Join(GetQualifiedFields(whereFields), " = ? AND ") + " = ? LIMIT 1"
	entities, err := queryCore(nil, nil, fieldsToSelect, q, x.GetFieldsValues(whereFields)...)
	if err != nil {
		return &QueryResult{Error: err, Exists: false}
	}
	if len(entities) == 0 {
		return &QueryResult{Exists: false}
	}
	*x = *entities[0]
	return &QueryResult{Exists: true}
}

func (x *Entity) DBExistsCtx(ctx context.Context, params *QueryParams) *QueryResult {
	if params == nil {
		return &QueryResult{Error: errors.New("DBExists requires params to be specified"), Exists: false}
	}
	fieldsToSelect := params.Select
	if len(fieldsToSelect) == 0 {
		fieldsToSelect = Fields
	}
	whereFields := params.Where
	if len(whereFields) == 0 {
		whereFields = Fields
	}
	q := "SELECT " + strings.Join(GetQualifiedFields(fieldsToSelect), ", ") + " FROM " + FQTN + " WHERE " + strings.Join(GetQualifiedFields(whereFields), " = ? AND ") + " = ? LIMIT 1"
	entities, err := queryCore(ctx, nil, fieldsToSelect, q, x.GetFieldsValues(whereFields)...)
	if err != nil {
		return &QueryResult{Error: err, Exists: false}
	}
	if len(entities) == 0 {
		return &QueryResult{Exists: false}
	}
	*x = *entities[0]
	return &QueryResult{Exists: true}
}

func (x *Entity) DBExistsTx(tx *sql.Tx, params *QueryParams) *QueryResult {
	if params == nil {
		return &QueryResult{Error: errors.New("DBExists requires params to be specified"), Exists: false}
	}
	fieldsToSelect := params.Select
	if len(fieldsToSelect) == 0 {
		fieldsToSelect = Fields
	}
	whereFields := params.Where
	if len(whereFields) == 0 {
		whereFields = Fields
	}
	q := "SELECT " + strings.Join(GetQualifiedFields(fieldsToSelect), ", ") + " FROM " + FQTN + " WHERE " + strings.Join(GetQualifiedFields(whereFields), " = ? AND ") + " = ? LIMIT 1"
	entities, err := queryCore(nil, tx, fieldsToSelect, q, x.GetFieldsValues(whereFields)...)
	if err != nil {
		return &QueryResult{Error: err, Exists: false}
	}
	if len(entities) == 0 {
		return &QueryResult{Exists: false}
	}
	*x = *entities[0]
	return &QueryResult{Exists: true}
}

func (x *Entity) DBExistsCtxTx(ctx context.Context, tx *sql.Tx, params *QueryParams) *QueryResult {
	if params == nil {
		return &QueryResult{Error: errors.New("DBExists requires params to be specified"), Exists: false}
	}
	fieldsToSelect := params.Select
	if len(fieldsToSelect) == 0 {
		fieldsToSelect = Fields
	}
	whereFields := params.Where
	if len(whereFields) == 0 {
		whereFields = Fields
	}
	q := "SELECT " + strings.Join(GetQualifiedFields(fieldsToSelect), ", ") + " FROM " + FQTN + " WHERE " + strings.Join(GetQualifiedFields(whereFields), " = ? AND ") + " = ? LIMIT 1"
	entities, err := queryCore(ctx, tx, fieldsToSelect, q, x.GetFieldsValues(whereFields)...)
	if err != nil {
		return &QueryResult{Error: err, Exists: false}
	}
	if len(entities) == 0 {
		return &QueryResult{Exists: false}
	}
	*x = *entities[0]
	return &QueryResult{Exists: true}
}
