package Alpha

// ---------------------------------------------------------------
// The code in this file is autogenerated, do not modify manually!
// ---------------------------------------------------------------

import (
	"context"
	"database/sql"
	"strings"
	"sync"
)

const (
	FQTN             = "`template`.`alpha`"
	FieldUuid        = "Uuid"
	FieldFirstInsert = "FirstInsert"
	FieldLastUpdate  = "LastUpdate"
	FieldAnimal      = "Animal"
	FieldBigNumber   = "BigNumber"
	FieldTestField   = "test_field"
)

var (
	Fields    = []string{FieldUuid, FieldFirstInsert, FieldLastUpdate, FieldAnimal, FieldBigNumber, FieldTestField}
	db        *sql.DB
	stmtMu    sync.RWMutex
	stmtCache = make(map[string]*sql.Stmt)
)

type Entity struct {
	Uuid        string
	FirstInsert string
	LastUpdate  string
	Animal      string
	BigNumber   string
	TestField   string
}

func SetDB(x *sql.DB) {
	db = x
}

func (x *Entity) GetFieldValues(fieldList []string) []any {
	values := make([]any, 0, len(fieldList))

	for _, field := range fieldList {
		switch field {
		case FieldUuid:
			values = append(values, x.Uuid)
		case FieldFirstInsert:
			values = append(values, x.FirstInsert)
		case FieldLastUpdate:
			values = append(values, x.LastUpdate)
		case FieldAnimal:
			values = append(values, x.Animal)
		case FieldBigNumber:
			values = append(values, x.BigNumber)
		case FieldTestField:
			values = append(values, x.TestField)
		}
	}

	return values
}

func GetFieldPlaceholders(fieldList []string) []string {
	placeholders := make([]string, 0, len(fieldList))

	for _, field := range fieldList {
		switch field {
		case FieldUuid:
			placeholders = append(placeholders, "?")
		case FieldFirstInsert:
			placeholders = append(placeholders, "?")
		case FieldLastUpdate:
			placeholders = append(placeholders, "?")
		case FieldAnimal:
			placeholders = append(placeholders, "?")
		case FieldBigNumber:
			placeholders = append(placeholders, "?")
		case FieldTestField:
			placeholders = append(placeholders, "?")
		}
	}

	return placeholders
}

func GetBacktickedField(field string) string {
	switch field {
	case FieldUuid:
		return FQTN + ".`" + FieldUuid + "`"
	case FieldFirstInsert:
		return FQTN + ".`" + FieldFirstInsert + "`"
	case FieldLastUpdate:
		return FQTN + ".`" + FieldLastUpdate + "`"
	case FieldAnimal:
		return FQTN + ".`" + FieldAnimal + "`"
	case FieldBigNumber:
		return FQTN + ".`" + FieldBigNumber + "`"
	case FieldTestField:
		return FQTN + ".`" + FieldTestField + "`"
	}
	return ""
}

func GetBacktickedFields(fieldList []string) []string {
	fields := make([]string, 0, len(fieldList))
	for _, field := range fieldList {
		fields = append(fields, GetBacktickedField(field))
	}
	return fields
}

func GetFieldPlaceholder(field string) string {
	switch field {
	case FieldUuid:
		return FQTN + ".`" + FieldUuid + "` = ?"
	case FieldFirstInsert:
		return FQTN + ".`" + FieldFirstInsert + "` = ?"
	case FieldLastUpdate:
		return FQTN + ".`" + FieldLastUpdate + "` = ?"
	case FieldAnimal:
		return FQTN + ".`" + FieldAnimal + "` = ?"
	case FieldBigNumber:
		return FQTN + ".`" + FieldBigNumber + "` = ?"
	case FieldTestField:
		return FQTN + ".`" + FieldTestField + "` = ?"
	}
	return ""
}

func GetFieldPlaceholdersWithName(fieldList []string) []string {
	placeholders := make([]string, 0, len(fieldList))
	for _, field := range fieldList {
		placeholders = append(placeholders, GetFieldPlaceholder(field))
	}
	return placeholders
}

func getPreparedStmt(query string) (*sql.Stmt, error) {
	stmtMu.RLock()
	if stmt, ok := stmtCache[query]; ok {
		stmtMu.RUnlock()
		return stmt, nil
	}
	stmtMu.RUnlock()

	stmtMu.Lock()
	defer stmtMu.Unlock()
	if stmt, ok := stmtCache[query]; ok {
		return stmt, nil
	}
	stmt, err := db.Prepare(query)
	if err != nil {
		return nil, err
	}
	stmtCache[query] = stmt
	return stmt, nil
}

func scanRow(fields []string, rows *sql.Rows) (*Entity, error) {
	x := &Entity{}
	var (
		ptrUuid        *string
		ptrFirstInsert *string
		ptrLastUpdate  *string
		ptrAnimal      *string
		ptrBigNumber   *string
		ptrTestField   *string
		scanTargets    []any
	)

	for _, field := range fields {
		switch field {
		case FieldUuid:
			scanTargets = append(scanTargets, &ptrUuid)
		case FieldFirstInsert:
			scanTargets = append(scanTargets, &ptrFirstInsert)
		case FieldLastUpdate:
			scanTargets = append(scanTargets, &ptrLastUpdate)
		case FieldAnimal:
			scanTargets = append(scanTargets, &ptrAnimal)
		case FieldBigNumber:
			scanTargets = append(scanTargets, &ptrBigNumber)
		case FieldTestField:
			scanTargets = append(scanTargets, &ptrTestField)
		}
	}

	err := rows.Scan(scanTargets...)
	if err != nil {
		return nil, err
	}

	if ptrUuid != nil {
		x.Uuid = *ptrUuid
	} else {
		x.Uuid = ""
	}
	if ptrFirstInsert != nil {
		x.FirstInsert = *ptrFirstInsert
	} else {
		x.FirstInsert = ""
	}
	if ptrLastUpdate != nil {
		x.LastUpdate = *ptrLastUpdate
	} else {
		x.LastUpdate = ""
	}
	if ptrAnimal != nil {
		x.Animal = *ptrAnimal
	} else {
		x.Animal = ""
	}
	if ptrBigNumber != nil {
		x.BigNumber = *ptrBigNumber
	} else {
		x.BigNumber = ""
	}
	if ptrTestField != nil {
		x.TestField = *ptrTestField
	} else {
		x.TestField = ""
	}
	return x, nil
}

func readRows(fields []string, rows *sql.Rows) ([]*Entity, error) {
	defer rows.Close()
	var results []*Entity
	for rows.Next() {
		x, err := scanRow(fields, rows)
		if err != nil {
			return results, err
		}
		results = append(results, x)
	}
	return results, nil
}

func DBTruncate() (sql.Result, error) {
	query := "TRUNCATE TABLE " + FQTN
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	return stmt.Exec()
}

func DBTruncateContext(ctx context.Context) (sql.Result, error) {
	query := "TRUNCATE TABLE " + FQTN
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	return stmt.ExecContext(ctx)
}

func (x *Entity) DBInsert(fieldsToInsert []string) (sql.Result, error) {
	query := "INSERT INTO " + FQTN + " (" + strings.Join(GetBacktickedFields(fieldsToInsert), ", ") + ") VALUES (" + strings.Join(GetFieldPlaceholders(fieldsToInsert), ", ") + ")"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	return stmt.Exec(x.GetFieldValues(fieldsToInsert)...)
}

func (x *Entity) DBInsertContext(ctx context.Context, fieldsToInsert []string) (sql.Result, error) {
	query := "INSERT INTO " + FQTN + " (" + strings.Join(GetBacktickedFields(fieldsToInsert), ", ") + ") VALUES (" + strings.Join(GetFieldPlaceholders(fieldsToInsert), ", ") + ")"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	return stmt.ExecContext(ctx, x.GetFieldValues(fieldsToInsert)...)
}

func (x *Entity) DBDeleteWhereAll(fieldsToMatch []string) (sql.Result, error) {
	query := "DELETE FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? AND ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	return stmt.Exec(x.GetFieldValues(fieldsToMatch)...)
}

func (x *Entity) DBDeleteWhereAllContext(ctx context.Context, fieldsToMatch []string) (sql.Result, error) {
	query := "DELETE FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? AND ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	return stmt.ExecContext(ctx, x.GetFieldValues(fieldsToMatch)...)
}

func (x *Entity) DBDeleteWhereAny(fieldsToMatch []string) (sql.Result, error) {
	query := "DELETE FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? OR ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	return stmt.Exec(x.GetFieldValues(fieldsToMatch)...)
}

func (x *Entity) DBDeleteWhereAnyContext(ctx context.Context, fieldsToMatch []string) (sql.Result, error) {
	query := "DELETE FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? OR ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	return stmt.ExecContext(ctx, x.GetFieldValues(fieldsToMatch)...)
}

func (x *Entity) DBUpdateWhereAll(fieldsToUpdate, fieldsToMatch []string) (sql.Result, error) {
	query := "UPDATE " + FQTN + " SET " + strings.Join(GetFieldPlaceholdersWithName(fieldsToUpdate), ", ") + " WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? AND ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	values := append(x.GetFieldValues(fieldsToUpdate), x.GetFieldValues(fieldsToMatch)...)
	return stmt.Exec(values...)
}

func (x *Entity) DBUpdateWhereAllContext(ctx context.Context, fieldsToUpdate, fieldsToMatch []string) (sql.Result, error) {
	query := "UPDATE " + FQTN + " SET " + strings.Join(GetFieldPlaceholdersWithName(fieldsToUpdate), ", ") + " WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? AND ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	values := append(x.GetFieldValues(fieldsToUpdate), x.GetFieldValues(fieldsToMatch)...)
	return stmt.ExecContext(ctx, values...)
}

func (x *Entity) DBUpdateWhereAny(fieldsToUpdate, fieldsToMatch []string) (sql.Result, error) {
	query := "UPDATE " + FQTN + " SET " + strings.Join(GetFieldPlaceholdersWithName(fieldsToUpdate), ", ") + " WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? OR ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	values := append(x.GetFieldValues(fieldsToUpdate), x.GetFieldValues(fieldsToMatch)...)
	return stmt.Exec(values...)
}

func (x *Entity) DBUpdateWhereAnyContext(ctx context.Context, fieldsToUpdate, fieldsToMatch []string) (sql.Result, error) {
	query := "UPDATE " + FQTN + " SET " + strings.Join(GetFieldPlaceholdersWithName(fieldsToUpdate), ", ") + " WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? OR ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	values := append(x.GetFieldValues(fieldsToUpdate), x.GetFieldValues(fieldsToMatch)...)
	return stmt.ExecContext(ctx, values...)
}

func DBSelectAll() ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.Query()
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(Fields, rows)
}

func DBSelectAllContext(ctx context.Context) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.QueryContext(ctx)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(Fields, rows)
}

func DBSelectAllWithFields(fields []string) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(fields), ", ") + " FROM " + FQTN
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.Query()
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(fields, rows)
}

func DBSelectAllWithFieldsContext(ctx context.Context, fields []string) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(fields), ", ") + " FROM " + FQTN
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.QueryContext(ctx)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(fields, rows)
}

func DBSubquerySelectAll(subquery string, args ...any) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN + " " + subquery
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.Query(args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(Fields, rows)
}

func DBSubquerySelectAllContext(ctx context.Context, subquery string, args ...any) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN + " " + subquery
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.QueryContext(ctx, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(Fields, rows)
}

func (x *Entity) DBSelectAllWhereAll(fieldsToMatch []string) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN +
		" WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? AND ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.Query(x.GetFieldValues(fieldsToMatch)...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(Fields, rows)
}

func (x *Entity) DBSelectAllWhereAllContext(ctx context.Context, fieldsToMatch []string) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN +
		" WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? AND ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.QueryContext(ctx, x.GetFieldValues(fieldsToMatch)...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(Fields, rows)
}

func (x *Entity) DBSelectAllWhereAny(fieldsToMatch []string) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN +
		" WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? OR ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.Query(x.GetFieldValues(fieldsToMatch)...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(Fields, rows)
}

func (x *Entity) DBSelectAllWhereAnyContext(ctx context.Context, fieldsToMatch []string) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN +
		" WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? OR ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.QueryContext(ctx, x.GetFieldValues(fieldsToMatch)...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(Fields, rows)
}

func (x *Entity) DBExists(fields []string) (bool, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") +
		" FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fields), " = ? AND ") + " = ? LIMIT 1"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return false, err
	}
	rows, err := stmt.Query(x.GetFieldValues(fields)...)
	if err != nil {
		return false, err
	}
	defer rows.Close()
	results, err := readRows(Fields, rows)
	if err != nil {
		return false, err
	}
	if len(results) == 0 {
		return false, nil
	}
	*x = *results[0]
	return true, nil
}

func (x *Entity) DBExistsContext(ctx context.Context, fields []string) (bool, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") +
		" FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fields), " = ? AND ") + " = ? LIMIT 1"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return false, err
	}
	rows, err := stmt.QueryContext(ctx, x.GetFieldValues(fields)...)
	if err != nil {
		return false, err
	}
	defer rows.Close()
	results, err := readRows(Fields, rows)
	if err != nil {
		return false, err
	}
	if len(results) == 0 {
		return false, nil
	}
	*x = *results[0]
	return true, nil
}

func (x *Entity) DBCountWhereAll(fields []string) (int, error) {
	query := "SELECT COUNT(*) FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fields), " = ? AND ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return 0, err
	}
	var count int
	err = stmt.QueryRow(x.GetFieldValues(fields)...).Scan(&count)
	return count, err
}

func (x *Entity) DBCountWhereAllContext(ctx context.Context, fields []string) (int, error) {
	query := "SELECT COUNT(*) FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fields), " = ? AND ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return 0, err
	}
	var count int
	err = stmt.QueryRowContext(ctx, x.GetFieldValues(fields)...).Scan(&count)
	return count, err
}

func (x *Entity) DBCountWhereAny(fields []string) (int, error) {
	query := "SELECT COUNT(*) FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fields), " = ? OR ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return 0, err
	}
	var count int
	err = stmt.QueryRow(x.GetFieldValues(fields)...).Scan(&count)
	return count, err
}

func (x *Entity) DBCountWhereAnyContext(ctx context.Context, fields []string) (int, error) {
	query := "SELECT COUNT(*) FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fields), " = ? OR ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return 0, err
	}
	var count int
	err = stmt.QueryRowContext(ctx, x.GetFieldValues(fields)...).Scan(&count)
	return count, err
}

func (x *Entity) DBFindOrCreate(fields []string) error {
	exists, err := x.DBExists(fields)
	if err != nil {
		return err
	}
	if exists {
		return nil
	}
	_, err = x.DBInsert(fields)
	if err != nil {
		return err
	}
	_, err = x.DBExists(fields)
	if err != nil {
		return err
	}
	return nil
}

func (x *Entity) DBFindOrCreateContext(ctx context.Context, fields []string) error {
	exists, err := x.DBExistsContext(ctx, fields)
	if err != nil {
		return err
	}
	if exists {
		return nil
	}
	_, err = x.DBInsertContext(ctx, fields)
	if err != nil {
		return err
	}
	_, err = x.DBExistsContext(ctx, fields)
	if err != nil {
		return err
	}
	return nil
}

func (x *Entity) DBSubquerySelectAllWhereAll(fieldsToMatch []string, subquery string, args ...any) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN +
		" WHERE (" + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? AND ") + " = ?) " + subquery
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	allArgs := append(x.GetFieldValues(fieldsToMatch), args...)
	rows, err := stmt.Query(allArgs...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(Fields, rows)
}

func (x *Entity) DBSubquerySelectAllWhereAllContext(ctx context.Context, fieldsToMatch []string, subquery string, args ...any) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN +
		" WHERE (" + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? AND ") + " = ?) " + subquery
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	allArgs := append(x.GetFieldValues(fieldsToMatch), args...)
	rows, err := stmt.QueryContext(ctx, allArgs...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(Fields, rows)
}

func (x *Entity) DBSubquerySelectAllWhereAny(fieldsToMatch []string, subquery string, args ...any) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN +
		" WHERE (" + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? OR ") + " = ?) " + subquery
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	allArgs := append(x.GetFieldValues(fieldsToMatch), args...)
	rows, err := stmt.Query(allArgs...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(Fields, rows)
}

func (x *Entity) DBSubquerySelectAllWhereAnyContext(ctx context.Context, fieldsToMatch []string, subquery string, args ...any) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN +
		" WHERE (" + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? OR ") + " = ?) " + subquery
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	allArgs := append(x.GetFieldValues(fieldsToMatch), args...)
	rows, err := stmt.QueryContext(ctx, allArgs...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(Fields, rows)
}
