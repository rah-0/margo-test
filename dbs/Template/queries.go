package Template

// ---------------------------------------------------------------
// The code in this file is autogenerated, do not modify manually!
// ---------------------------------------------------------------

import (
	"context"
	"database/sql"
	"encoding/base64"
	"errors"
	"sync"

	"github.com/rah-0/margo-test/dbs/Template/AllTypes"
	"github.com/rah-0/margo-test/dbs/Template/Alpha"
	"github.com/rah-0/margo-test/dbs/Template/Beta"
)

var (
	db        *sql.DB
	stmtMu    sync.RWMutex
	stmtCache = make(map[string]*sql.Stmt)
	queries   = map[string]*NamedQuery{
		"CountBigNumbers":  {QueryEncoded: "U0VMRUNUIENPVU5UKCopIEFTIGBjb3VudGAKRlJPTSBgYWxwaGFgCldIRVJFIGBCaWdOdW1iZXJgIElTIE5VTEw="},
		"DeleteByUuid":     {QueryEncoded: "REVMRVRFIEZST00gYGFscGhhYCBXSEVSRSBgVXVpZGAgPSA/"},
		"DeleteOldRows":    {QueryEncoded: "REVMRVRFIEZST00gYGFscGhhYCBXSEVSRSBgTGFzdFVwZGF0ZWAgPCAnMjAyMy0wMS0wMSAwMDowMDowMC4wMDAwMDAn"},
		"GetByUuid":        {QueryEncoded: "U0VMRUNUIGBBbmltYWxgLCBgdGVzdF9maWVsZGAKRlJPTSBgYWxwaGFgCldIRVJFIGBVdWlkYCA9ID8="},
		"GetRecentCats":    {QueryEncoded: "U0VMRUNUIGBVdWlkYCwgYExhc3RVcGRhdGVgCkZST00gYGFscGhhYApXSEVSRSBgQW5pbWFsYCA9ICdjYXQnIEFORCBgTGFzdFVwZGF0ZWAgPiAnMjAyNC0wMS0wMSAwMDowMDowMC4wMDAwMDAn"},
		"InsertHardcoded":  {QueryEncoded: "SU5TRVJUIElOVE8gYGFscGhhYCAoYFV1aWRgLCBgQW5pbWFsYCkKVkFMVUVTICgnMTExMTExMTEtMTExMS00MTExLTgxMTEtMTExMTExMTExMTExJywgJ2RvZycp"},
		"InsertOne":        {QueryEncoded: "SU5TRVJUIElOVE8gYGFscGhhYCAoYFV1aWRgLCBgQW5pbWFsYCwgYHRlc3RfZmllbGRgKQpWQUxVRVMgKD8sID8sID8p"},
		"SampleTest":       {QueryEncoded: "V0lUSCBzZWxlY3RlZF91c2VyX3BsYW4gQVMgKAogICAgU0VMRUNUIHVwLnVzZXJfaWQsIHVwLnBsYW5faWQKICAgIEZST00gdXNlcl9wbGFuIHVwCiAgICAgICAgICAgICBKT0lOIHBsYW4gcCBPTiBwLmlkID0gdXAucGxhbl9pZAogICAgV0hFUkUgdXAudXNlcl9pZCA9ID8KICAgIE9SREVSIEJZIHAucHJpY2UgREVTQwogICAgTElNSVQgMQopClNFTEVDVAogICAgQ09BTEVTQ0UoU1VNKGYuc2l6ZV9ieXRlcyksIDApIEFTIHRvdGFsX3N0b3JhZ2VfdXNlZCwKICAgIChDT1VOVChmLmlkKSA+PSBwLm1heF9maWxlX2NvdW50KSBBUyByZWFjaGVkX2ZpbGVfbGltaXQsCiAgICAoQ09BTEVTQ0UoU1VNKGYuc2l6ZV9ieXRlcyksIDApID49IHAubWF4X3N0b3JhZ2VfYnl0ZXMpIEFTIGV4Y2VlZGVkX3N0b3JhZ2VfbGltaXQKRlJPTSBzZWxlY3RlZF91c2VyX3BsYW4gc3AKICAgICAgICAgSk9JTiBwbGFuIHAgT04gcC5pZCA9IHNwLnBsYW5faWQKICAgICAgICAgTEVGVCBKT0lOIGZpbGUgZiBPTiBmLnVzZXJfaWQgPSBzcC51c2VyX2lkCkdST1VQIEJZIHNwLnVzZXJfaWQsIHAubWF4X2ZpbGVfY291bnQsIHAubWF4X3N0b3JhZ2VfYnl0ZXM="},
		"UpdateAnimalName": {QueryEncoded: "VVBEQVRFIGBhbHBoYWAKU0VUIGBBbmltYWxgID0gPwpXSEVSRSBgVXVpZGAgPSA/"},
		"UpdateTestField":  {QueryEncoded: "VVBEQVRFIGBhbHBoYWAKU0VUIGB0ZXN0X2ZpZWxkYCA9ICd1cGRhdGVkJwpXSEVSRSBgQW5pbWFsYCA9ICdmb3gn"},
	}
)

type NamedQuery struct {
	Name         string
	Query        string
	QueryEncoded string
}

type QueryParams struct {
	Params []any
}

func NewQueryParams() *QueryParams {
	return &QueryParams{}
}

func (qp *QueryParams) WithParams(params ...any) *QueryParams {
	qp.Params = params
	return qp
}

func SetDB(x *sql.DB) error {
	db = x

	for _, q := range queries {
		b, err := base64.StdEncoding.DecodeString(q.QueryEncoded)
		if err != nil {
			return err
		}
		q.Query = string(b)
	}

	if err := AllTypes.SetDB(x); err != nil {
		return err
	}
	if err := Alpha.SetDB(x); err != nil {
		return err
	}
	if err := Beta.SetDB(x); err != nil {
		return err
	}

	return nil
}

func NewTx() (*sql.Tx, error) {
	if db == nil {
		return nil, errors.New("db not initialized")
	}
	return db.Begin()
}

func NewCtxTx(ctx context.Context) (*sql.Tx, error) {
	if db == nil {
		return nil, errors.New("db not initialized")
	}
	return db.BeginTx(ctx, nil)
}

func NewTxOpts(opts *sql.TxOptions) (*sql.Tx, error) {
	if db == nil {
		return nil, errors.New("db not initialized")
	}
	return db.BeginTx(context.Background(), opts)
}

func NewCtxTxOpts(ctx context.Context, opts *sql.TxOptions) (*sql.Tx, error) {
	if db == nil {
		return nil, errors.New("db not initialized")
	}
	return db.BeginTx(ctx, opts)
}

func getPreparedStmt(query string) (*sql.Stmt, error) {
	stmtMu.RLock()
	if stmt, ok := stmtCache[query]; ok {
		stmtMu.RUnlock()
		return stmt, nil
	}
	stmtMu.RUnlock()

	stmtMu.Lock()
	defer stmtMu.Unlock()
	if stmt, ok := stmtCache[query]; ok {
		return stmt, nil
	}
	stmt, err := db.Prepare(query)
	if err != nil {
		return nil, err
	}
	stmtCache[query] = stmt
	return stmt, nil
}

func bindStmtCtxTx(base *sql.Stmt, ctx context.Context, tx *sql.Tx) (*sql.Stmt, bool) {
	if tx == nil {
		return base, false
	}
	if ctx != nil {
		return tx.StmtContext(ctx, base), true
	}
	return tx.Stmt(base), true
}

type QueryCountBigNumbersResultInner struct {
	Count string
}

type QueryCountBigNumbersResult struct {
	Entity *QueryCountBigNumbersResultInner
	Error  error
	Result sql.Result
	Exists bool
}

func queryCountBigNumbers(ctx context.Context, tx *sql.Tx, params *QueryParams) (qr *QueryCountBigNumbersResult) {
	qr = &QueryCountBigNumbersResult{}
	q := queries["CountBigNumbers"]
	base, err := getPreparedStmt(q.Query)
	if err != nil {
		qr.Error = err
		return
	}

	stmt, needClose := bindStmtCtxTx(base, ctx, tx)
	if needClose {
		defer func() {
			if cerr := stmt.Close(); err == nil && cerr != nil {
				qr.Error = cerr
			}
		}()
	}

	var ptrCount *string
	if ctx != nil {
		err = stmt.QueryRowContext(ctx).Scan(&ptrCount)
	} else {
		err = stmt.QueryRow().Scan(&ptrCount)
	}
	if errors.Is(err, sql.ErrNoRows) {
		return
	}
	if err != nil {
		qr.Error = err
		return
	}

	x := &QueryCountBigNumbersResultInner{}
	if ptrCount != nil {
		x.Count = *ptrCount
	} else {
		x.Count = ""
	}
	qr.Entity = x
	qr.Exists = true
	return
}

func QueryCountBigNumbers() *QueryCountBigNumbersResult { return queryCountBigNumbers(nil, nil, nil) }
func QueryCountBigNumbersCtx(ctx context.Context) *QueryCountBigNumbersResult {
	return queryCountBigNumbers(ctx, nil, nil)
}
func QueryCountBigNumbersTx(tx *sql.Tx) *QueryCountBigNumbersResult {
	return queryCountBigNumbers(nil, tx, nil)
}
func QueryCountBigNumbersCtxTx(ctx context.Context, tx *sql.Tx) *QueryCountBigNumbersResult {
	return queryCountBigNumbers(ctx, tx, nil)
}

type QueryDeleteByUuidResult struct {
	Error  error
	Result sql.Result
}

func queryDeleteByUuid(ctx context.Context, tx *sql.Tx, params *QueryParams) (qr *QueryDeleteByUuidResult) {
	qr = &QueryDeleteByUuidResult{}
	q := queries["DeleteByUuid"]
	base, err := getPreparedStmt(q.Query)
	if err != nil {
		qr.Error = err
		return
	}

	stmt, needClose := bindStmtCtxTx(base, ctx, tx)
	if needClose {
		defer func() {
			if cerr := stmt.Close(); err == nil && cerr != nil {
				qr.Error = cerr
			}
		}()
	}

	var res sql.Result
	if ctx != nil {
		res, err = stmt.ExecContext(ctx, params.Params...)
	} else {
		res, err = stmt.Exec(params.Params...)
	}
	qr.Result = res
	qr.Error = err
	return
}

func ExecDeleteByUuid(params *QueryParams) *QueryDeleteByUuidResult {
	return queryDeleteByUuid(nil, nil, params)
}
func ExecDeleteByUuidCtx(ctx context.Context, params *QueryParams) *QueryDeleteByUuidResult {
	return queryDeleteByUuid(ctx, nil, params)
}
func ExecDeleteByUuidTx(tx *sql.Tx, params *QueryParams) *QueryDeleteByUuidResult {
	return queryDeleteByUuid(nil, tx, params)
}
func ExecDeleteByUuidCtxTx(ctx context.Context, tx *sql.Tx, params *QueryParams) *QueryDeleteByUuidResult {
	return queryDeleteByUuid(ctx, tx, params)
}

type QueryDeleteOldRowsResult struct {
	Error  error
	Result sql.Result
}

func queryDeleteOldRows(ctx context.Context, tx *sql.Tx, params *QueryParams) (qr *QueryDeleteOldRowsResult) {
	qr = &QueryDeleteOldRowsResult{}
	q := queries["DeleteOldRows"]
	base, err := getPreparedStmt(q.Query)
	if err != nil {
		qr.Error = err
		return
	}

	stmt, needClose := bindStmtCtxTx(base, ctx, tx)
	if needClose {
		defer func() {
			if cerr := stmt.Close(); err == nil && cerr != nil {
				qr.Error = cerr
			}
		}()
	}

	var res sql.Result
	if ctx != nil {
		res, err = stmt.ExecContext(ctx)
	} else {
		res, err = stmt.Exec()
	}
	qr.Result = res
	qr.Error = err
	return
}

func ExecDeleteOldRows() *QueryDeleteOldRowsResult { return queryDeleteOldRows(nil, nil, nil) }
func ExecDeleteOldRowsCtx(ctx context.Context) *QueryDeleteOldRowsResult {
	return queryDeleteOldRows(ctx, nil, nil)
}
func ExecDeleteOldRowsTx(tx *sql.Tx) *QueryDeleteOldRowsResult {
	return queryDeleteOldRows(nil, tx, nil)
}
func ExecDeleteOldRowsCtxTx(ctx context.Context, tx *sql.Tx) *QueryDeleteOldRowsResult {
	return queryDeleteOldRows(ctx, tx, nil)
}

type QueryGetByUuidResultInner struct {
	Animal    string
	TestField string
}

type QueryGetByUuidResult struct {
	Entity *QueryGetByUuidResultInner
	Error  error
	Result sql.Result
	Exists bool
}

func queryGetByUuid(ctx context.Context, tx *sql.Tx, params *QueryParams) (qr *QueryGetByUuidResult) {
	qr = &QueryGetByUuidResult{}
	q := queries["GetByUuid"]
	base, err := getPreparedStmt(q.Query)
	if err != nil {
		qr.Error = err
		return
	}

	stmt, needClose := bindStmtCtxTx(base, ctx, tx)
	if needClose {
		defer func() {
			if cerr := stmt.Close(); err == nil && cerr != nil {
				qr.Error = cerr
			}
		}()
	}

	var ptrAnimal *string
	var ptrTestField *string
	if ctx != nil {
		err = stmt.QueryRowContext(ctx, params.Params...).Scan(&ptrAnimal, &ptrTestField)
	} else {
		err = stmt.QueryRow(params.Params...).Scan(&ptrAnimal, &ptrTestField)
	}
	if errors.Is(err, sql.ErrNoRows) {
		return
	}
	if err != nil {
		qr.Error = err
		return
	}

	x := &QueryGetByUuidResultInner{}
	if ptrAnimal != nil {
		x.Animal = *ptrAnimal
	} else {
		x.Animal = ""
	}
	if ptrTestField != nil {
		x.TestField = *ptrTestField
	} else {
		x.TestField = ""
	}
	qr.Entity = x
	qr.Exists = true
	return
}

func QueryGetByUuid(params *QueryParams) *QueryGetByUuidResult {
	return queryGetByUuid(nil, nil, params)
}
func QueryGetByUuidCtx(ctx context.Context, params *QueryParams) *QueryGetByUuidResult {
	return queryGetByUuid(ctx, nil, params)
}
func QueryGetByUuidTx(tx *sql.Tx, params *QueryParams) *QueryGetByUuidResult {
	return queryGetByUuid(nil, tx, params)
}
func QueryGetByUuidCtxTx(ctx context.Context, tx *sql.Tx, params *QueryParams) *QueryGetByUuidResult {
	return queryGetByUuid(ctx, tx, params)
}

type QueryGetRecentCatsResultInner struct {
	Uuid       string
	LastUpdate string
}

type QueryGetRecentCatsResult struct {
	Entities []*QueryGetRecentCatsResultInner
	Error    error
	Result   sql.Result
}

func queryGetRecentCats(ctx context.Context, tx *sql.Tx, params *QueryParams) (qr *QueryGetRecentCatsResult) {
	qr = &QueryGetRecentCatsResult{}
	q := queries["GetRecentCats"]
	base, err := getPreparedStmt(q.Query)
	if err != nil {
		qr.Error = err
		return
	}

	stmt, needClose := bindStmtCtxTx(base, ctx, tx)
	if needClose {
		defer func() {
			if cerr := stmt.Close(); err == nil && cerr != nil {
				qr.Error = cerr
			}
		}()
	}

	var rows *sql.Rows
	if ctx != nil {
		rows, err = stmt.QueryContext(ctx)
	} else {
		rows, err = stmt.Query()
	}
	if err != nil {
		qr.Error = err
		return
	}
	defer rows.Close()

	for rows.Next() {
		var ptrUuid *string
		var ptrLastUpdate *string
		if err = rows.Scan(&ptrUuid, &ptrLastUpdate); err != nil {
			qr.Error = err
			return
		}
		x := QueryGetRecentCatsResultInner{}
		if ptrUuid != nil {
			x.Uuid = *ptrUuid
		} else {
			x.Uuid = ""
		}
		if ptrLastUpdate != nil {
			x.LastUpdate = *ptrLastUpdate
		} else {
			x.LastUpdate = ""
		}
		qr.Entities = append(qr.Entities, &x)
	}
	if err = rows.Err(); err != nil {
		qr.Error = err
		return
	}
	return
}

func QueryGetRecentCats() *QueryGetRecentCatsResult { return queryGetRecentCats(nil, nil, nil) }
func QueryGetRecentCatsCtx(ctx context.Context) *QueryGetRecentCatsResult {
	return queryGetRecentCats(ctx, nil, nil)
}
func QueryGetRecentCatsTx(tx *sql.Tx) *QueryGetRecentCatsResult {
	return queryGetRecentCats(nil, tx, nil)
}
func QueryGetRecentCatsCtxTx(ctx context.Context, tx *sql.Tx) *QueryGetRecentCatsResult {
	return queryGetRecentCats(ctx, tx, nil)
}

type QueryInsertHardcodedResult struct {
	Error  error
	Result sql.Result
}

func queryInsertHardcoded(ctx context.Context, tx *sql.Tx, params *QueryParams) (qr *QueryInsertHardcodedResult) {
	qr = &QueryInsertHardcodedResult{}
	q := queries["InsertHardcoded"]
	base, err := getPreparedStmt(q.Query)
	if err != nil {
		qr.Error = err
		return
	}

	stmt, needClose := bindStmtCtxTx(base, ctx, tx)
	if needClose {
		defer func() {
			if cerr := stmt.Close(); err == nil && cerr != nil {
				qr.Error = cerr
			}
		}()
	}

	var res sql.Result
	if ctx != nil {
		res, err = stmt.ExecContext(ctx)
	} else {
		res, err = stmt.Exec()
	}
	qr.Result = res
	qr.Error = err
	return
}

func ExecInsertHardcoded() *QueryInsertHardcodedResult { return queryInsertHardcoded(nil, nil, nil) }
func ExecInsertHardcodedCtx(ctx context.Context) *QueryInsertHardcodedResult {
	return queryInsertHardcoded(ctx, nil, nil)
}
func ExecInsertHardcodedTx(tx *sql.Tx) *QueryInsertHardcodedResult {
	return queryInsertHardcoded(nil, tx, nil)
}
func ExecInsertHardcodedCtxTx(ctx context.Context, tx *sql.Tx) *QueryInsertHardcodedResult {
	return queryInsertHardcoded(ctx, tx, nil)
}

type QueryInsertOneResult struct {
	Error  error
	Result sql.Result
}

func queryInsertOne(ctx context.Context, tx *sql.Tx, params *QueryParams) (qr *QueryInsertOneResult) {
	qr = &QueryInsertOneResult{}
	q := queries["InsertOne"]
	base, err := getPreparedStmt(q.Query)
	if err != nil {
		qr.Error = err
		return
	}

	stmt, needClose := bindStmtCtxTx(base, ctx, tx)
	if needClose {
		defer func() {
			if cerr := stmt.Close(); err == nil && cerr != nil {
				qr.Error = cerr
			}
		}()
	}

	var res sql.Result
	if ctx != nil {
		res, err = stmt.ExecContext(ctx, params.Params...)
	} else {
		res, err = stmt.Exec(params.Params...)
	}
	qr.Result = res
	qr.Error = err
	return
}

func ExecInsertOne(params *QueryParams) *QueryInsertOneResult {
	return queryInsertOne(nil, nil, params)
}
func ExecInsertOneCtx(ctx context.Context, params *QueryParams) *QueryInsertOneResult {
	return queryInsertOne(ctx, nil, params)
}
func ExecInsertOneTx(tx *sql.Tx, params *QueryParams) *QueryInsertOneResult {
	return queryInsertOne(nil, tx, params)
}
func ExecInsertOneCtxTx(ctx context.Context, tx *sql.Tx, params *QueryParams) *QueryInsertOneResult {
	return queryInsertOne(ctx, tx, params)
}

type QuerySampleTestResultInner struct {
	TotalStorageUsed     string
	ReachedFileLimit     string
	ExceededStorageLimit string
}

type QuerySampleTestResult struct {
	Entity *QuerySampleTestResultInner
	Error  error
	Result sql.Result
	Exists bool
}

func querySampleTest(ctx context.Context, tx *sql.Tx, params *QueryParams) (qr *QuerySampleTestResult) {
	qr = &QuerySampleTestResult{}
	q := queries["SampleTest"]
	base, err := getPreparedStmt(q.Query)
	if err != nil {
		qr.Error = err
		return
	}

	stmt, needClose := bindStmtCtxTx(base, ctx, tx)
	if needClose {
		defer func() {
			if cerr := stmt.Close(); err == nil && cerr != nil {
				qr.Error = cerr
			}
		}()
	}

	var ptrTotalStorageUsed *string
	var ptrReachedFileLimit *string
	var ptrExceededStorageLimit *string
	if ctx != nil {
		err = stmt.QueryRowContext(ctx, params.Params...).Scan(&ptrTotalStorageUsed, &ptrReachedFileLimit, &ptrExceededStorageLimit)
	} else {
		err = stmt.QueryRow(params.Params...).Scan(&ptrTotalStorageUsed, &ptrReachedFileLimit, &ptrExceededStorageLimit)
	}
	if errors.Is(err, sql.ErrNoRows) {
		return
	}
	if err != nil {
		qr.Error = err
		return
	}

	x := &QuerySampleTestResultInner{}
	if ptrTotalStorageUsed != nil {
		x.TotalStorageUsed = *ptrTotalStorageUsed
	} else {
		x.TotalStorageUsed = ""
	}
	if ptrReachedFileLimit != nil {
		x.ReachedFileLimit = *ptrReachedFileLimit
	} else {
		x.ReachedFileLimit = ""
	}
	if ptrExceededStorageLimit != nil {
		x.ExceededStorageLimit = *ptrExceededStorageLimit
	} else {
		x.ExceededStorageLimit = ""
	}
	qr.Entity = x
	qr.Exists = true
	return
}

func QuerySampleTest(params *QueryParams) *QuerySampleTestResult {
	return querySampleTest(nil, nil, params)
}
func QuerySampleTestCtx(ctx context.Context, params *QueryParams) *QuerySampleTestResult {
	return querySampleTest(ctx, nil, params)
}
func QuerySampleTestTx(tx *sql.Tx, params *QueryParams) *QuerySampleTestResult {
	return querySampleTest(nil, tx, params)
}
func QuerySampleTestCtxTx(ctx context.Context, tx *sql.Tx, params *QueryParams) *QuerySampleTestResult {
	return querySampleTest(ctx, tx, params)
}

type QueryUpdateAnimalNameResult struct {
	Error  error
	Result sql.Result
}

func queryUpdateAnimalName(ctx context.Context, tx *sql.Tx, params *QueryParams) (qr *QueryUpdateAnimalNameResult) {
	qr = &QueryUpdateAnimalNameResult{}
	q := queries["UpdateAnimalName"]
	base, err := getPreparedStmt(q.Query)
	if err != nil {
		qr.Error = err
		return
	}

	stmt, needClose := bindStmtCtxTx(base, ctx, tx)
	if needClose {
		defer func() {
			if cerr := stmt.Close(); err == nil && cerr != nil {
				qr.Error = cerr
			}
		}()
	}

	var res sql.Result
	if ctx != nil {
		res, err = stmt.ExecContext(ctx, params.Params...)
	} else {
		res, err = stmt.Exec(params.Params...)
	}
	qr.Result = res
	qr.Error = err
	return
}

func ExecUpdateAnimalName(params *QueryParams) *QueryUpdateAnimalNameResult {
	return queryUpdateAnimalName(nil, nil, params)
}
func ExecUpdateAnimalNameCtx(ctx context.Context, params *QueryParams) *QueryUpdateAnimalNameResult {
	return queryUpdateAnimalName(ctx, nil, params)
}
func ExecUpdateAnimalNameTx(tx *sql.Tx, params *QueryParams) *QueryUpdateAnimalNameResult {
	return queryUpdateAnimalName(nil, tx, params)
}
func ExecUpdateAnimalNameCtxTx(ctx context.Context, tx *sql.Tx, params *QueryParams) *QueryUpdateAnimalNameResult {
	return queryUpdateAnimalName(ctx, tx, params)
}

type QueryUpdateTestFieldResult struct {
	Error  error
	Result sql.Result
}

func queryUpdateTestField(ctx context.Context, tx *sql.Tx, params *QueryParams) (qr *QueryUpdateTestFieldResult) {
	qr = &QueryUpdateTestFieldResult{}
	q := queries["UpdateTestField"]
	base, err := getPreparedStmt(q.Query)
	if err != nil {
		qr.Error = err
		return
	}

	stmt, needClose := bindStmtCtxTx(base, ctx, tx)
	if needClose {
		defer func() {
			if cerr := stmt.Close(); err == nil && cerr != nil {
				qr.Error = cerr
			}
		}()
	}

	var res sql.Result
	if ctx != nil {
		res, err = stmt.ExecContext(ctx)
	} else {
		res, err = stmt.Exec()
	}
	qr.Result = res
	qr.Error = err
	return
}

func ExecUpdateTestField() *QueryUpdateTestFieldResult { return queryUpdateTestField(nil, nil, nil) }
func ExecUpdateTestFieldCtx(ctx context.Context) *QueryUpdateTestFieldResult {
	return queryUpdateTestField(ctx, nil, nil)
}
func ExecUpdateTestFieldTx(tx *sql.Tx) *QueryUpdateTestFieldResult {
	return queryUpdateTestField(nil, tx, nil)
}
func ExecUpdateTestFieldCtxTx(ctx context.Context, tx *sql.Tx) *QueryUpdateTestFieldResult {
	return queryUpdateTestField(ctx, tx, nil)
}
