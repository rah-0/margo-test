package Beta

// ---------------------------------------------------------------
// The code in this file is autogenerated, do not modify manually!
// ---------------------------------------------------------------

import (
	"context"
	"database/sql"
	"strings"
	"sync"
)

const (
	FQTN             = "`template`.`beta`"
	FieldFirstInsert = "first_insert"
	FieldLastUpdate  = "last_update"
	FieldUuid        = "uuid"
	FieldName        = "name"
)

var (
	Fields    = []string{FieldFirstInsert, FieldLastUpdate, FieldUuid, FieldName}
	db        *sql.DB
	stmtMu    sync.RWMutex
	stmtCache = make(map[string]*sql.Stmt)
)

type Entity struct {
	FirstInsert string
	LastUpdate  string
	Uuid        string
	Name        string
}

func SetDB(x *sql.DB) {
	db = x
}

func (x *Entity) GetFieldValues(fieldList []string) []any {
	values := make([]any, 0, len(fieldList))

	for _, field := range fieldList {
		switch field {
		case FieldFirstInsert:
			values = append(values, x.FirstInsert)
		case FieldLastUpdate:
			values = append(values, x.LastUpdate)
		case FieldUuid:
			values = append(values, x.Uuid)
		case FieldName:
			values = append(values, x.Name)
		}
	}

	return values
}

func GetFieldPlaceholders(fieldList []string) []string {
	placeholders := make([]string, 0, len(fieldList))

	for _, field := range fieldList {
		switch field {
		case FieldFirstInsert:
			placeholders = append(placeholders, "?")
		case FieldLastUpdate:
			placeholders = append(placeholders, "?")
		case FieldUuid:
			placeholders = append(placeholders, "?")
		case FieldName:
			placeholders = append(placeholders, "?")
		}
	}

	return placeholders
}

func GetFieldPlaceholdersWithName(fieldList []string) []string {
	placeholders := make([]string, 0, len(fieldList))

	for _, field := range fieldList {
		switch field {
		case FieldFirstInsert:
			placeholders = append(placeholders, "`"+FieldFirstInsert+"` = ?")
		case FieldLastUpdate:
			placeholders = append(placeholders, "`"+FieldLastUpdate+"` = ?")
		case FieldUuid:
			placeholders = append(placeholders, "`"+FieldUuid+"` = ?")
		case FieldName:
			placeholders = append(placeholders, "`"+FieldName+"` = ?")
		}
	}

	return placeholders
}

func GetBacktickedFields(fieldList []string) []string {
	fields := make([]string, 0, len(fieldList))

	for _, field := range fieldList {
		switch field {
		case FieldFirstInsert:
			fields = append(fields, "`"+FieldFirstInsert+"`")
		case FieldLastUpdate:
			fields = append(fields, "`"+FieldLastUpdate+"`")
		case FieldUuid:
			fields = append(fields, "`"+FieldUuid+"`")
		case FieldName:
			fields = append(fields, "`"+FieldName+"`")
		}
	}

	return fields
}

func getPreparedStmt(query string) (*sql.Stmt, error) {
	stmtMu.RLock()
	if stmt, ok := stmtCache[query]; ok {
		stmtMu.RUnlock()
		return stmt, nil
	}
	stmtMu.RUnlock()

	stmtMu.Lock()
	defer stmtMu.Unlock()
	if stmt, ok := stmtCache[query]; ok {
		return stmt, nil
	}
	stmt, err := db.Prepare(query)
	if err != nil {
		return nil, err
	}
	stmtCache[query] = stmt
	return stmt, nil
}

func scanRow(rows *sql.Rows) (*Entity, error) {
	x := &Entity{}
	var ptrFirstInsert *string
	var ptrLastUpdate *string
	var ptrUuid *string
	var ptrName *string
	err := rows.Scan(
		&ptrFirstInsert,
		&ptrLastUpdate,
		&ptrUuid,
		&ptrName,
	)
	if err != nil {
		return nil, err
	}
	if ptrFirstInsert != nil {
		x.FirstInsert = *ptrFirstInsert
	} else {
		x.FirstInsert = ""
	}
	if ptrLastUpdate != nil {
		x.LastUpdate = *ptrLastUpdate
	} else {
		x.LastUpdate = ""
	}
	if ptrUuid != nil {
		x.Uuid = *ptrUuid
	} else {
		x.Uuid = ""
	}
	if ptrName != nil {
		x.Name = *ptrName
	} else {
		x.Name = ""
	}
	return x, nil
}

func readRows(rows *sql.Rows) ([]*Entity, error) {
	defer rows.Close()
	var results []*Entity
	for rows.Next() {
		x, err := scanRow(rows)
		if err != nil {
			return results, err
		}
		results = append(results, x)
	}
	return results, nil
}

func DBTruncate() (sql.Result, error) {
	query := "TRUNCATE TABLE " + FQTN
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	return stmt.Exec()
}

func DBTruncateContext(ctx context.Context) (sql.Result, error) {
	query := "TRUNCATE TABLE " + FQTN
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	return stmt.ExecContext(ctx)
}

func (x *Entity) DBInsert(fieldsToInsert []string) (sql.Result, error) {
	query := "INSERT INTO " + FQTN + " (" + strings.Join(GetBacktickedFields(fieldsToInsert), ", ") + ") VALUES (" + strings.Join(GetFieldPlaceholders(fieldsToInsert), ", ") + ")"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	return stmt.Exec(x.GetFieldValues(fieldsToInsert)...)
}

func (x *Entity) DBInsertContext(ctx context.Context, fieldsToInsert []string) (sql.Result, error) {
	query := "INSERT INTO " + FQTN + " (" + strings.Join(GetBacktickedFields(fieldsToInsert), ", ") + ") VALUES (" + strings.Join(GetFieldPlaceholders(fieldsToInsert), ", ") + ")"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	return stmt.ExecContext(ctx, x.GetFieldValues(fieldsToInsert)...)
}

func (x *Entity) DBDeleteWhereAll(fieldsToMatch []string) (sql.Result, error) {
	query := "DELETE FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? AND ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	return stmt.Exec(x.GetFieldValues(fieldsToMatch)...)
}

func (x *Entity) DBDeleteWhereAllContext(ctx context.Context, fieldsToMatch []string) (sql.Result, error) {
	query := "DELETE FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? AND ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	return stmt.ExecContext(ctx, x.GetFieldValues(fieldsToMatch)...)
}

func (x *Entity) DBDeleteWhereAny(fieldsToMatch []string) (sql.Result, error) {
	query := "DELETE FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? OR ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	return stmt.Exec(x.GetFieldValues(fieldsToMatch)...)
}

func (x *Entity) DBDeleteWhereAnyContext(ctx context.Context, fieldsToMatch []string) (sql.Result, error) {
	query := "DELETE FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? OR ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	return stmt.ExecContext(ctx, x.GetFieldValues(fieldsToMatch)...)
}

func (x *Entity) DBUpdateWhereAll(fieldsToUpdate, fieldsToMatch []string) (sql.Result, error) {
	query := "UPDATE " + FQTN + " SET " + strings.Join(GetFieldPlaceholdersWithName(fieldsToUpdate), ", ") + " WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? AND ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	values := append(x.GetFieldValues(fieldsToUpdate), x.GetFieldValues(fieldsToMatch)...)
	return stmt.Exec(values...)
}

func (x *Entity) DBUpdateWhereAllContext(ctx context.Context, fieldsToUpdate, fieldsToMatch []string) (sql.Result, error) {
	query := "UPDATE " + FQTN + " SET " + strings.Join(GetFieldPlaceholdersWithName(fieldsToUpdate), ", ") + " WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? AND ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	values := append(x.GetFieldValues(fieldsToUpdate), x.GetFieldValues(fieldsToMatch)...)
	return stmt.ExecContext(ctx, values...)
}

func (x *Entity) DBUpdateWhereAny(fieldsToUpdate, fieldsToMatch []string) (sql.Result, error) {
	query := "UPDATE " + FQTN + " SET " + strings.Join(GetFieldPlaceholdersWithName(fieldsToUpdate), ", ") + " WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? OR ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	values := append(x.GetFieldValues(fieldsToUpdate), x.GetFieldValues(fieldsToMatch)...)
	return stmt.Exec(values...)
}

func (x *Entity) DBUpdateWhereAnyContext(ctx context.Context, fieldsToUpdate, fieldsToMatch []string) (sql.Result, error) {
	query := "UPDATE " + FQTN + " SET " + strings.Join(GetFieldPlaceholdersWithName(fieldsToUpdate), ", ") + " WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? OR ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	values := append(x.GetFieldValues(fieldsToUpdate), x.GetFieldValues(fieldsToMatch)...)
	return stmt.ExecContext(ctx, values...)
}

func DBSelectAll() ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.Query()
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(rows)
}

func DBSelectAllContext(ctx context.Context) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.QueryContext(ctx)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(rows)
}

func DBSelectAllWithFields(fields []string) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(fields), ", ") + " FROM " + FQTN
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.Query()
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(rows)
}

func DBSelectAllWithFieldsContext(ctx context.Context, fields []string) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(fields), ", ") + " FROM " + FQTN
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.QueryContext(ctx)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(rows)
}

func DBSubquerySelectAll(subquery string, args ...any) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN + " " + subquery
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.Query(args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(rows)
}

func DBSubquerySelectAllContext(ctx context.Context, subquery string, args ...any) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN + " " + subquery
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.QueryContext(ctx, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(rows)
}

func (x *Entity) DBSelectAllWhereAll(fieldsToMatch []string) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN +
		" WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? AND ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.Query(x.GetFieldValues(fieldsToMatch)...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(rows)
}

func (x *Entity) DBSelectAllWhereAllContext(ctx context.Context, fieldsToMatch []string) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN +
		" WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? AND ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.QueryContext(ctx, x.GetFieldValues(fieldsToMatch)...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(rows)
}

func (x *Entity) DBSelectAllWhereAny(fieldsToMatch []string) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN +
		" WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? OR ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.Query(x.GetFieldValues(fieldsToMatch)...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(rows)
}

func (x *Entity) DBSelectAllWhereAnyContext(ctx context.Context, fieldsToMatch []string) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN +
		" WHERE " + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? OR ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	rows, err := stmt.QueryContext(ctx, x.GetFieldValues(fieldsToMatch)...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(rows)
}

func (x *Entity) DBExists(fields []string) (bool, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") +
		" FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fields), " = ? AND ") + " = ? LIMIT 1"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return false, err
	}
	rows, err := stmt.Query(x.GetFieldValues(fields)...)
	if err != nil {
		return false, err
	}
	defer rows.Close()
	results, err := readRows(rows)
	if err != nil {
		return false, err
	}
	if len(results) == 0 {
		return false, nil
	}
	*x = *results[0]
	return true, nil
}

func (x *Entity) DBExistsContext(ctx context.Context, fields []string) (bool, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") +
		" FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fields), " = ? AND ") + " = ? LIMIT 1"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return false, err
	}
	rows, err := stmt.QueryContext(ctx, x.GetFieldValues(fields)...)
	if err != nil {
		return false, err
	}
	defer rows.Close()
	results, err := readRows(rows)
	if err != nil {
		return false, err
	}
	if len(results) == 0 {
		return false, nil
	}
	*x = *results[0]
	return true, nil
}

func (x *Entity) DBCountWhereAll(fields []string) (int, error) {
	query := "SELECT COUNT(*) FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fields), " = ? AND ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return 0, err
	}
	var count int
	err = stmt.QueryRow(x.GetFieldValues(fields)...).Scan(&count)
	return count, err
}

func (x *Entity) DBCountWhereAllContext(ctx context.Context, fields []string) (int, error) {
	query := "SELECT COUNT(*) FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fields), " = ? AND ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return 0, err
	}
	var count int
	err = stmt.QueryRowContext(ctx, x.GetFieldValues(fields)...).Scan(&count)
	return count, err
}

func (x *Entity) DBCountWhereAny(fields []string) (int, error) {
	query := "SELECT COUNT(*) FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fields), " = ? OR ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return 0, err
	}
	var count int
	err = stmt.QueryRow(x.GetFieldValues(fields)...).Scan(&count)
	return count, err
}

func (x *Entity) DBCountWhereAnyContext(ctx context.Context, fields []string) (int, error) {
	query := "SELECT COUNT(*) FROM " + FQTN + " WHERE " + strings.Join(GetBacktickedFields(fields), " = ? OR ") + " = ?"
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return 0, err
	}
	var count int
	err = stmt.QueryRowContext(ctx, x.GetFieldValues(fields)...).Scan(&count)
	return count, err
}

func (x *Entity) DBFindOrCreate(fields []string) error {
	exists, err := x.DBExists(fields)
	if err != nil {
		return err
	}
	if exists {
		return nil
	}
	_, err = x.DBInsert(fields)
	if err != nil {
		return err
	}
	_, err = x.DBExists(fields)
	if err != nil {
		return err
	}
	return nil
}

func (x *Entity) DBFindOrCreateContext(ctx context.Context, fields []string) error {
	exists, err := x.DBExistsContext(ctx, fields)
	if err != nil {
		return err
	}
	if exists {
		return nil
	}
	_, err = x.DBInsertContext(ctx, fields)
	if err != nil {
		return err
	}
	_, err = x.DBExistsContext(ctx, fields)
	if err != nil {
		return err
	}
	return nil
}

func (x *Entity) DBSubquerySelectAllWhereAll(fieldsToMatch []string, subquery string, args ...any) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN +
		" WHERE (" + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? AND ") + " = ?) " + subquery
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	allArgs := append(x.GetFieldValues(fieldsToMatch), args...)
	rows, err := stmt.Query(allArgs...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(rows)
}

func (x *Entity) DBSubquerySelectAllWhereAllContext(ctx context.Context, fieldsToMatch []string, subquery string, args ...any) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN +
		" WHERE (" + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? AND ") + " = ?) " + subquery
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	allArgs := append(x.GetFieldValues(fieldsToMatch), args...)
	rows, err := stmt.QueryContext(ctx, allArgs...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(rows)
}

func (x *Entity) DBSubquerySelectAllWhereAny(fieldsToMatch []string, subquery string, args ...any) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN +
		" WHERE (" + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? OR ") + " = ?) " + subquery
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	allArgs := append(x.GetFieldValues(fieldsToMatch), args...)
	rows, err := stmt.Query(allArgs...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(rows)
}

func (x *Entity) DBSubquerySelectAllWhereAnyContext(ctx context.Context, fieldsToMatch []string, subquery string, args ...any) ([]*Entity, error) {
	query := "SELECT " + strings.Join(GetBacktickedFields(Fields), ", ") + " FROM " + FQTN +
		" WHERE (" + strings.Join(GetBacktickedFields(fieldsToMatch), " = ? OR ") + " = ?) " + subquery
	stmt, err := getPreparedStmt(query)
	if err != nil {
		return nil, err
	}
	allArgs := append(x.GetFieldValues(fieldsToMatch), args...)
	rows, err := stmt.QueryContext(ctx, allArgs...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	return readRows(rows)
}
